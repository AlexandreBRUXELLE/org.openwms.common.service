<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocationGroup.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenWMS.org COMMON: Services</a> &gt; <a href="index.source.html" class="el_package">org.openwms.common.location</a> &gt; <span class="el_source">LocationGroup.java</span></div><h1>LocationGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2018 Heiko Scherrer
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openwms.common.location;

import org.ameba.exception.ServiceLayerException;
import org.openwms.common.StateChangeException;
import org.openwms.common.location.api.LocationGroupState;
import org.springframework.util.Assert;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

/**
 * A LocationGroup is a logical group of {@code Location}s with same characteristics. This is useful
 *
 * @author Heiko Scherrer
 * @GlossaryTerm
 * @see org.openwms.common.location.Location
 */
@Entity
@Table(name = &quot;COM_LOCATION_GROUP&quot;)
public class LocationGroup extends Target implements Serializable {

    /** Unique identifier of a {@code LocationGroup}. */
    @Column(name = &quot;C_NAME&quot;, unique = true, nullable = false, length = LENGTH_NAME)
    private String name;
    /** Length of the name field; used for telegram mapping and for column definition. */
    public static final int LENGTH_NAME = 20;

    /** Description for the {@code LocationGroup}. */
    @Column(name = &quot;C_DESCRIPTION&quot;)
    private String description;

    /** A type can be assigned to a {@code LocationGroup}. */
    @Column(name = &quot;C_GROUP_TYPE&quot;)
    private String groupType;

    /** Is the {@code LocationGroup} included in the calculation of {@code TransportUnit}s. */
    @Column(name = &quot;C_GROUP_COUNTING_ACTIVE&quot;)
<span class="fc" id="L66">    private boolean locationGroupCountingActive = true;</span>

    /** General state controlled by the subsystem only. */
    @Column(name = &quot;C_GROUP_STATE&quot;)
    @Enumerated(EnumType.STRING)
<span class="fc" id="L71">    private LocationGroupState groupState = LocationGroupState.AVAILABLE;</span>

    /** State of infeed, controlled by the subsystem only. */
    @Column(name = &quot;C_GROUP_STATE_IN&quot;)
    @Enumerated(EnumType.STRING)
<span class="fc" id="L76">    private LocationGroupState groupStateIn = LocationGroupState.AVAILABLE;</span>

    /** References the {@code LocationGroup} that locked this {@code LocationGroup} for infeed. */
    @ManyToOne
    @JoinColumn(name = &quot;C_IN_LOCKER&quot;)
    private LocationGroup stateInLocker;

    /** State of outfeed. */
    @Column(name = &quot;C_GROUP_STATE_OUT&quot;)
    @Enumerated(EnumType.STRING)
<span class="fc" id="L86">    private LocationGroupState groupStateOut = LocationGroupState.AVAILABLE;</span>

    /** References the {@code LocationGroup} that locked this {@code LocationGroup} for outfeed. */
    @ManyToOne
    @JoinColumn(name = &quot;C_OUT_LOCKER&quot;)
    private LocationGroup stateOutLocker;

    /** Maximum fill level of the {@code LocationGroup}. */
    @Column(name = &quot;C_MAX_FILL_LEVEL&quot;)
<span class="fc" id="L95">    private float maxFillLevel = 0;</span>

    /** The subsystem like a PLC, that manages this {@code LocationGroup}. */
    @Embedded
    private Subsystem subsystem;

    /* ------------------- collection mapping ------------------- */
    /** Parent {@code LocationGroup}. */
    @ManyToOne
    @JoinColumn(name = &quot;C_PARENT&quot;)
    private LocationGroup parent;

    /** Child {@code LocationGroup}s. */
    @OneToMany(mappedBy = &quot;parent&quot;, cascade = {CascadeType.ALL})
<span class="fc" id="L109">    private Set&lt;LocationGroup&gt; locationGroups = new HashSet&lt;&gt;();</span>

    /** Child {@link Location}s. */
    @OneToMany(mappedBy = &quot;locationGroup&quot;)
<span class="fc" id="L113">    private Set&lt;Location&gt; locations = new HashSet&lt;&gt;();</span>

    /*~ ----------------------------- constructors ------------------- */
    /** Dear JPA... */
<span class="fc" id="L117">    protected LocationGroup() { }</span>

    /**
     * Create a new {@code LocationGroup} with an unique name.
     *
     * @param name The name of the {@code LocationGroup} must not be {@literal null}
     */
<span class="fc" id="L124">    public LocationGroup(@NotEmpty String name) {</span>
<span class="fc" id="L125">        Assert.hasText(name, &quot;Creation of LocationGroup with name null&quot;);</span>
<span class="fc" id="L126">        this.name = name;</span>
<span class="fc" id="L127">    }</span>

    /*~ ----------------------------- methods ------------------- */

    /**
     * Returns the name of the {@code LocationGroup}.
     *
     * @return The name of the {@code LocationGroup}
     */
    public String getName() {
<span class="fc" id="L137">        return name;</span>
    }

    /**
     * Check whether infeed is allowed for the {@code LocationGroup}.
     *
     * @return {@literal true} if allowed, otherwise {@literal false}.
     */
    public boolean isInfeedAllowed() {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        return (getGroupStateIn() == LocationGroupState.AVAILABLE);</span>
    }

    /**
     * Check whether infeed of the {@code LocationGroup} is blocked.
     *
     * @return {@literal true} if blocked, otherwise {@literal false}.
     */
    public boolean isInfeedBlocked() {
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        return !isInfeedAllowed();</span>
    }

    /**
     * Check whether outfeed is allowed for the {@code LocationGroup}.
     *
     * @return {@literal true} if allowed, otherwise {@literal false}.
     */
    public boolean isOutfeedAllowed() {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        return (getGroupStateIn() == LocationGroupState.AVAILABLE);</span>
    }

    /**
     * Check whether outfeed of the {@code LocationGroup} is blocked.
     *
     * @return {@literal true} if blocked, otherwise {@literal false}.
     */
    public boolean isOutfeedBlocked() {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        return !isInfeedAllowed();</span>
    }

    /**
     * Returns the infeed state of the {@code LocationGroup}.
     *
     * @return The state of infeed
     */
    public LocationGroupState getGroupStateIn() {
<span class="fc" id="L182">        return this.groupStateIn;</span>
    }

    /**
     * Change the infeed state of the {@code LocationGroup}.
     *
     * @param newGroupStateIn The state to set
     */
    public void changeGroupStateIn(LocationGroupState newGroupStateIn) {
<span class="pc bpc" id="L191" title="1 of 4 branches missed.">        if (stateInLocker != null &amp;&amp; stateInLocker != this) {</span>
<span class="fc" id="L192">            throw new StateChangeException(&quot;The LocationGroup's state is blocked by any other LocationGroup and cannot be changed&quot;);</span>
        }
<span class="fc" id="L194">        groupStateIn = newGroupStateIn;</span>
<span class="fc" id="L195">        locationGroups.forEach(lg -&gt; lg.changeGroupStateIn(newGroupStateIn, this));</span>
<span class="fc" id="L196">    }</span>

    /**
     * Change the infeed state of the {@code LocationGroup}.
     *
     * @param newGroupStateIn The state to set
     * @param lockLG The {@code LocationGroup} that wants to lock/unlock this {@code LocationGroup}.
     */
    private void changeGroupStateIn(LocationGroupState newGroupStateIn, LocationGroup lockLG) {
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        if (groupStateIn == LocationGroupState.NOT_AVAILABLE &amp;&amp; newGroupStateIn == LocationGroupState.AVAILABLE) {</span>

            // unlock
<span class="fc" id="L208">            stateInLocker = null;</span>
        }
<span class="fc bfc" id="L210" title="All 4 branches covered.">        if (groupStateIn == LocationGroupState.AVAILABLE &amp;&amp; newGroupStateIn == LocationGroupState.NOT_AVAILABLE) {</span>

            // lock
<span class="fc" id="L213">            stateInLocker = lockLG;</span>
        }
<span class="fc" id="L215">        groupStateIn = newGroupStateIn;</span>
<span class="pc" id="L216">        locationGroups.forEach(lg -&gt; lg.changeGroupStateIn(newGroupStateIn, lockLG));</span>
<span class="fc" id="L217">    }</span>

    /**
     * Return the outfeed state of the {@code LocationGroup}.
     *
     * @return The state of outfeed
     */
    public LocationGroupState getGroupStateOut() {
<span class="fc" id="L225">        return groupStateOut;</span>
    }

    /**
     * Change the outfeed state of the {@code LocationGroup}.
     *
     * @param newGroupStateOut The state to set
     */
    public void changeGroupStateOut(LocationGroupState newGroupStateOut) {
<span class="nc bnc" id="L234" title="All 4 branches missed.">        if (stateOutLocker != null &amp;&amp; stateOutLocker != this) {</span>
<span class="nc" id="L235">            throw new StateChangeException(&quot;The LocationGroup's state is blocked by any other LocationGroup and cannot be changed&quot;);</span>
        }
<span class="nc" id="L237">        groupStateOut = newGroupStateOut;</span>
<span class="nc" id="L238">        locationGroups.forEach(lg -&gt; lg.changeGroupStateOut(newGroupStateOut, this));</span>
<span class="nc" id="L239">    }</span>

    /**
     * Set the outfeed state of the {@code LocationGroup}.
     *
     * @param gStateOut The state to set
     * @param lockLg The {@code LocationGroup} that wants to lock/unlock this {@code LocationGroup}.
     */
    void changeGroupStateOut(LocationGroupState gStateOut, LocationGroup lockLg) {
<span class="pc bpc" id="L248" title="3 of 8 branches missed.">        if (this.groupStateOut == LocationGroupState.NOT_AVAILABLE &amp;&amp; gStateOut == LocationGroupState.AVAILABLE &amp;&amp; (this.stateOutLocker == null || this.stateOutLocker.equals(lockLg))) {</span>
<span class="fc" id="L249">            this.groupStateOut = gStateOut;</span>
<span class="fc" id="L250">            this.stateOutLocker = null;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            for (LocationGroup child : locationGroups) {</span>
<span class="fc" id="L252">                child.changeGroupStateOut(gStateOut, lockLg);</span>
            }
        }
<span class="pc bpc" id="L255" title="4 of 8 branches missed.">        if (this.groupStateOut == LocationGroupState.AVAILABLE &amp;&amp; gStateOut == LocationGroupState.NOT_AVAILABLE &amp;&amp; (this.stateOutLocker == null || this.stateOutLocker.equals(lockLg))) {</span>
<span class="fc" id="L256">            this.groupStateOut = gStateOut;</span>
<span class="fc" id="L257">            this.stateOutLocker = lockLg;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            for (LocationGroup child : locationGroups) {</span>
<span class="fc" id="L259">                child.changeGroupStateOut(gStateOut, lockLg);</span>
            }
        }
<span class="fc" id="L262">    }</span>

    /**
     * Returns the count of all sub {@link Location}s.
     *
     * @return The count of {@link Location}s belonging to this {@code LocationGroup}
     */
    public int getNoLocations() {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        return this.locations != null ? this.locations.size() : 0;</span>
    }

    /**
     * Returns the maximum fill level of the {@code LocationGroup}.&lt;br&gt; The maximum fill level defines how many {@link Location}s of the
     * {@code LocationGroup} can be occupied by {@code TransportUnit}s. &lt;p&gt; The maximum fill level is a value between 0 and 1 and represents
     * a percentage value. &lt;/p&gt;
     *
     * @return The maximum fill level
     */
    public float getMaxFillLevel() {
<span class="fc" id="L281">        return this.maxFillLevel;</span>
    }

    /**
     * Set the maximum fill level for the {@code LocationGroup}. &lt;p&gt; Pass a value between 0 and 1.&lt;br&gt; For example maxFillLevel = 0.85
     * means: 85% of all {@link Location}s can be occupied. &lt;/p&gt;
     *
     * @param maxFillLevel The maximum fill level
     */
    public void setMaxFillLevel(float maxFillLevel) {
<span class="nc" id="L291">        this.maxFillLevel = maxFillLevel;</span>
<span class="nc" id="L292">    }</span>

    /**
     * Returns the type of the {@code LocationGroup}.
     *
     * @return The type of the {@code LocationGroup}
     */
    public String getGroupType() {
<span class="nc" id="L300">        return this.groupType;</span>
    }

    /**
     * Set the type for the {@code LocationGroup}.
     *
     * @param groupType The type of the {@code LocationGroup}
     */
    public void setGroupType(String groupType) {
<span class="nc" id="L309">        this.groupType = groupType;</span>
<span class="nc" id="L310">    }</span>

    /**
     * Returns the description text.
     *
     * @return The Description as String
     */
    public String getDescription() {
<span class="nc" id="L318">        return this.description;</span>
    }

    /**
     * Set the description text.
     *
     * @param description The String to set as description text
     */
    public void setDescription(String description) {
<span class="nc" id="L327">        this.description = description;</span>
<span class="nc" id="L328">    }</span>

    /**
     * Returns the parent {@code LocationGroup}.
     *
     * @return The parent {@code LocationGroup}
     */
    public LocationGroup getParent() {
<span class="fc" id="L336">        return this.parent;</span>
    }

    /**
     * Return all child {@code LocationGroup}.
     *
     * @return A set of all {@code LocationGroup} having this one as parent
     */
    public Set&lt;LocationGroup&gt; getLocationGroups() {
<span class="fc" id="L345">        return locationGroups;</span>
    }

    /**
     * Add a {@code LocationGroup} to the list of children.
     *
     * @param locationGroup The {@code LocationGroup} to be added as a child
     * @return {@literal true} if the {@code LocationGroup} was new in the collection of {@code LocationGroup}s, otherwise {@literal false}
     */
    public boolean addLocationGroup(LocationGroup locationGroup) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (locationGroup == null) {</span>
<span class="fc" id="L356">            throw new IllegalArgumentException(&quot;LocationGroup to be added is null&quot;);</span>
        }
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (locationGroup.parent != null) {</span>
<span class="fc" id="L359">            locationGroup.parent.removeLocationGroup(locationGroup);</span>
        }
<span class="fc" id="L361">        locationGroup.parent = this;</span>
<span class="fc" id="L362">        locationGroup.changeGroupStateIn(groupStateIn, this);</span>
<span class="fc" id="L363">        locationGroup.changeGroupStateOut(groupStateOut, this);</span>
<span class="fc" id="L364">        return locationGroups.add(locationGroup);</span>
    }

    /**
     * Remove a {@code LocationGroup} from the list of children.
     *
     * @param locationGroup The {@code LocationGroup} to be removed from the list of children
     * @return {@literal true} if the {@code LocationGroup} was found and could be removed, otherwise {@literal false}
     */
    public boolean removeLocationGroup(@NotNull LocationGroup locationGroup) {
<span class="pc" id="L374">        Assert.notNull(locationGroup, () -&gt; &quot;LocationGroup to remove is null. this: &quot; + this);</span>
<span class="fc" id="L375">        locationGroup.parent = null;</span>
<span class="fc" id="L376">        return locationGroups.remove(locationGroup);</span>
    }

    /**
     * Return all {@link Location}s.
     *
     * @return {@link Location}s
     */
    public Set&lt;Location&gt; getLocations() {
<span class="fc" id="L385">        return locations;</span>
    }

    /**
     * Check whether this {@code LocationGroup} has {@code Location}s assigned.
     *
     * @return {@literal true} if {@code Location}s are assigned, otherwise {@literal false}
     */
    public boolean hasLocations() {
<span class="pc bpc" id="L394" title="1 of 4 branches missed.">        return locations != null &amp;&amp; !locations.isEmpty();</span>
    }

    /**
     * Add a {@link Location} to the list of children.
     *
     * @param location The {@link Location} to be added as child
     * @return {@literal true} if the {@link Location} was new in the collection of {@link Location}s, otherwise {@literal false}
     */
    public boolean addLocation(Location location) {
<span class="fc" id="L404">        Assert.notNull(location, () -&gt; &quot;Location to be added to LocationGroup is null. this: &quot; + this);</span>
<span class="fc" id="L405">        location.setLocationGroup(this);</span>
<span class="fc" id="L406">        return locations.add(location);</span>
    }

    /**
     * Remove a {@link Location} from the list of children.
     *
     * @param location The {@link Location} to be removed from the list of children
     * @return {@literal true} if the {@link Location} was found and could be removed, otherwise {@literal false}
     */
    public boolean removeLocation(Location location) {
<span class="fc" id="L416">        Assert.notNull(location, () -&gt; &quot;Location to remove from LocationGroup is null. this: &quot; + this);</span>
<span class="fc" id="L417">        location.unsetLocationGroup();</span>
<span class="fc" id="L418">        return locations.remove(location);</span>
    }

    /**
     * Returns the locationGroupCountingActive.
     *
     * @return The locationGroupCountingActive
     */
    public boolean isLocationGroupCountingActive() {
<span class="fc" id="L427">        return locationGroupCountingActive;</span>
    }

    /**
     * Set the locationGroupCountingActive.
     *
     * @param locationGroupCountingActive The locationGroupCountingActive to set
     */
    public void setLocationGroupCountingActive(boolean locationGroupCountingActive) {
<span class="fc" id="L436">        this.locationGroupCountingActive = locationGroupCountingActive;</span>
<span class="fc" id="L437">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="fc" id="L446">        final int prime = 31;</span>
<span class="fc" id="L447">        int result = 111;</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        result = prime * result + ((name == null) ? 0 : name.hashCode());</span>
<span class="fc" id="L449">        return result;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L460">            return true;</span>
        }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (!(obj instanceof LocationGroup)) {</span>
<span class="nc" id="L463">            return false;</span>
        }
<span class="fc" id="L465">        LocationGroup other = (LocationGroup) obj;</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (other.name != null) {</span>
<span class="nc" id="L468">                return false;</span>
            }
<span class="fc bfc" id="L470" title="All 2 branches covered.">        } else if (!name.equals(other.name)) {</span>
<span class="fc" id="L471">            return false;</span>
        }
<span class="fc" id="L473">        return true;</span>
    }

    /**
     * Return the name of the {@code LocationGroup} as String.
     *
     * @return The name
     */
    @Override
    public String toString() {
<span class="fc" id="L483">        return getName();</span>
    }

    /**
     * Tries to change the {@code groupStateIn} and {@code groupStateOut} of the {@code LocationGroup}. A state change is only allowed when
     * the parent {@code LocationGroup}s state is not blocked.
     *
     * @param stateIn The new groupStateIn to set, or {@literal null}
     * @param stateOut The new groupStateOut to set, or {@literal null}
     */
    public void changeState(LocationGroupState stateIn, LocationGroupState stateOut) {
<span class="nc bnc" id="L494" title="All 4 branches missed.">        if (groupStateIn != stateIn &amp;&amp; stateIn != null) {</span>
            // GroupStateIn changed
<span class="nc bnc" id="L496" title="All 6 branches missed.">            if (parent != null &amp;&amp; parent.getGroupStateIn() == LocationGroupState.NOT_AVAILABLE &amp;&amp; groupStateIn == LocationGroupState.AVAILABLE) {</span>
<span class="nc" id="L497">                throw new ServiceLayerException(&quot;Not allowed to change GroupStateIn, parent locationGroup is not available&quot;);</span>
            }
<span class="nc" id="L499">            changeGroupStateIn(stateIn, this);</span>
        }
<span class="nc bnc" id="L501" title="All 4 branches missed.">        if (groupStateOut != stateOut &amp;&amp; stateOut != null) {</span>
            // GroupStateOut changed
<span class="nc bnc" id="L503" title="All 6 branches missed.">            if (parent != null &amp;&amp; parent.getGroupStateOut() == LocationGroupState.NOT_AVAILABLE &amp;&amp; groupStateOut == LocationGroupState.AVAILABLE) {</span>
<span class="nc" id="L504">                throw new ServiceLayerException(&quot;Not allowed to change GroupStateOut, parent locationGroup is not available&quot;);</span>
            }
<span class="nc" id="L506">            changeGroupStateOut(stateOut, this);</span>
        }
<span class="nc" id="L508">    }</span>

    /**
     * Whether this LocationGroup has a parent LocationGroup or not.
     *
     * @return {@literal true} If it has a parent
     */
    public boolean hasParent() {
<span class="nc bnc" id="L516" title="All 2 branches missed.">        return parent != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>